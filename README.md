# プログラミングコンテストチャレンジブック

蟻本を Python と Go で実装しながら勉強する
学んだことをなるべくここに整理していく

## 2 初級編

### 2-1 全探索

- 再帰関数：
  関数の中で同じ関数を呼び出す関数
  同じ値を何回も参照する場合は，メモ化をすることで高速化できる
- スタック：
  push と pop ができるデータ構造（LIFO）
- キュー：
  push と pop ができるデータ構造（FIFO）

- 深さ優先探索（DFS）：
  ある状態からはじめ遷移できなるなる状態まで進めていき，遷移できなくなったら１つ前の状態に戻るということを繰り返して解を見つける方法
  全ての状態に対して処理を行いたい場合に使う
  最大の再起の深さに比例するメモリが必要（一般的に幅優先よりメモリ使用量は少ない）

- 枝刈り：
  深さ優先探索でこれ以上いくら遷移していっても解が存在しないことが明らかな時に，それ以上探索せずに打ち切ってしまうこと

- 幅優先探索（BFS）：
  ある状態から 1 回で辿り着ける全ての状態を探索するのを繰り返して解を見つける方法．
  キューに次々と状態を入れていくので，状態すうに比例するメモリを必要とする

- 反復深化深さ優先探索（IDDFS）：
  深さ優先の再帰の回数をはじめは 1 回に制限しておき，解が見つからなければどんどん再帰を深くしていく手法

**Column スタック領域とヒープ領域**
スタック領域：関数を呼び出す時に，呼び出し元の関数におけるローカル変数などの情報を保存しておく領域
ヒープ領域：new や malloc などで確保するメモリの領域

スタック領域はプログラム起動時に一括で確保されるため，後から拡張できない．スタック領域には限界があるので，関数を再帰する回数には限界がある．C や C ＋＋では数万回の再帰が可能．

グローバル変数はヒープ領域に保存される．通常，グローバル変数は嫌われるが，コンテストのプログラムでは，関数がそれほど多くない上，いろんな関数から１つの配列をアクセスすることが多いので，グローバル変数を利用すると便利．

### 2-2 貪欲法

### 2-3 動的計画法

### 2-4 データ構造

### 2-5 グラフ

### 2-6 数学的な問題

### 2-7 GCJ の問題に挑戦

## 3 中級編

### 二分探索

### 頻出テクニック

### データ構造

### 動的計画法を極める

### ネットワークフロー

### 計算幾何

### GCJ の問題に挑戦してみよう

## 上級編

### 複雑な数学的問題

### ゲームの必勝法

### グラフマスター

### 頻出テクニック

### 工夫を凝らして探索

### 分割統治法

### 文字列を扱う

### GCJ の問題に挑戦してみよう
